源码阅读（参照：java-design-patterns中经过改造的主从reactor模式）
----------------------------------------------

# TimeServer

**执行过程概述**


**主程序**

```java
class TimeServer {
    
    public static void main(String[] args) {
        //程序入口
        new TimeServer(8180).run();
    }

    public void run() {
        //线程池1：mainReactor，监听accept事件并转发到subReactor
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        //线程池2：subReactor，监听读写事件，同时执行具体任务
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            //启动辅助程序，build模式
            ServerBootstrap bootstrap = new ServerBootstrap();
            //设置启动参数
            bootstrap
                //设置主从线程池(parentGroup/childGroup)
                .group(bossGroup, workerGroup)
                //根据Class创建Factory，后续通过反射生产Channel实例
                .channel(NioServerSocketChannel.class)
                //添加channel的处理器链
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) {
                        ch.pipeline().addLast(new TimeEncoder(), new TimeServerHandler());
                    }
                })
                //为MainChannel设置参数列表
                .option(ChannelOption.SO_BACKLOG, 128)
                //为SubChannel设置参数列表
                .childOption(ChannelOption.SO_KEEPALIVE, true);
            //正式启动：绑定端口并监听即将到来的连接
            ChannelFuture channelFuture = bootstrap
                //程序主体：主要操作都在这里，具体见doBind
                .bind(port)
                //具体见sync
                .sync();

            // Wait until the server socket is closed.
            // In this example, this does not happen, but you can do that to gracefully
            // shut down your server.
            channelFuture
                .channel()
                .closeFuture()
                .sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    /**
    * 程序主要执行部分
    */
    private ChannelFuture doBind(final SocketAddress localAddress) {
        /**
        * 初始化channel并注册到selector上
        * 异步：netty中几乎所有操作都是封装为task再通过EventLoopGroup线程池异步执行，具体的执行者就是EventLoop线程
        * ChannelFuture：一次异步IO的执行结果
        */
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }

        if (regFuture.isDone()) {
            /**
            * 表示执行到这里时channel已经注册完毕
            * ChannelPromise：可写的特异化ChannelFuture
            */
            ChannelPromise promise = channel.newPromise();
            //
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            // Registration future is almost always fulfilled already, but just in case it's not.
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    } else {
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();

                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
}